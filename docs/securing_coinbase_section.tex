
\section{Securing the Transfer of Coinbase Funds in the Quantum Era}
\label{sec:securing-coinbase}

We introduce a framework that combines STARK proofs~\cite{ben2018scalable} with a lattice-based signature scheme (ML-DSA, formerly CRYSTALS-Dilithium~\cite{fips204}) to enable blockchain address owners to transition to quantum-resistant key material \emph{without exposing their classical elliptic-curve public keys on-chain}. The framework accommodates two distinct threat models---addresses whose public keys have already been revealed and those whose keys remain hidden behind hash pre-images---and provides a graduated migration path for each.

\subsection{STARK Circuit for Bitcoin Address Migration}
\label{subsec:btc-circuit}

\subsubsection{Setting}

Consider a Bitcoin user who controls a P2PKH unspent transaction output (UTXO) associated with a secp256k1 key pair $(sk, Q)$, where $Q = sk \cdot G$ is the 33-byte compressed public key and the on-chain address $a$ is the standard Base58Check encoding of $\mathrm{RIPEMD\text{-}160}(\mathrm{SHA\text{-}256}(Q))$. The user generates a post-quantum key pair $(sk_{pq}, pk_{pq})$ under FIPS-204 (ML-DSA) and wishes to publicly bind $pk_{pq}$ to address~$a$ while proving knowledge of~$sk$ in zero knowledge.

\subsubsection{Address Derivation within the Circuit}

The circuit internally re-derives the P2PKH address from the (private) compressed public key~$Q$ through the following deterministic pipeline:

\begin{enumerate}[label=\textbf{(\roman*)}]
    \item Compute $h_1 = \mathrm{SHA\text{-}256}(Q)$.
    \item Compute $h_2 = \mathrm{RIPEMD\text{-}160}(h_1)$.
    \item Compute the checksum $c_4 = \mathrm{SHA\text{-}256}^{2}(\texttt{0x00} \| h_2)[0{:}4]$.
    \item Form the address $a' = \texttt{0x00} \| h_2 \| c_4$.
\end{enumerate}

\subsubsection{Circuit Specification}

The STARK circuit partitions its inputs into public and private sets:

\begin{itemize}
    \item \textbf{Public inputs (statement):} The UTXO address $a \in \{0,1\}^{200}$ and the post-quantum public key $pk_{pq}$.
    \item \textbf{Private inputs (witness):} The compressed elliptic-curve public key $Q \in \{0,1\}^{264}$ and the ECDSA signature $\sigma \in \{0,1\}^{512}$.
\end{itemize}

The circuit enforces two constraints:

\begin{enumerate}[label=\textbf{C\arabic*.}]
    \item \textbf{Address binding.} The internally derived address must match the declared UTXO address:
    \[
        a' = f_{\text{P2PKH}}(Q) \stackrel{!}{=} a
    \]
    where $f_{\text{P2PKH}}$ denotes the four-step derivation pipeline defined above. This ensures the prover cannot claim ownership of an address controlled by a different key.

    \item \textbf{Ownership proof.} The ECDSA signature must be valid under $Q$ over the message $m = \mathrm{SHA\text{-}256}(a)$:
    \[
        \mathrm{ECDSA.Verify}\bigl(Q,\; \mathrm{SHA\text{-}256}(a),\; \sigma\bigr) \stackrel{!}{=} 1
    \]
    This establishes that the prover possesses the private key $sk$ such that $Q = sk \cdot G$ on secp256k1, without revealing $Q$ or $sk$ to the verifier.
\end{enumerate}

Upon satisfaction of both constraints, the circuit commits the tuple $(a, pk_{pq})$ as ABI-encoded public values, producing a STARK proof $\pi$ that attests: \emph{``the holder of address $a$ authorizes binding $pk_{pq}$ as its quantum-resistant successor key.''}

\subsection{STARK Circuit for Ethereum Address Migration}
\label{subsec:eth-circuit}

\subsubsection{Setting}

Consider an Ethereum externally owned account (EOA) controlled by a secp256k1 key pair $(sk, Q_u)$, where $Q_u$ is the 65-byte uncompressed public key (with \texttt{0x04} prefix). The Ethereum address is derived as the trailing 20 bytes of the Keccak-256 digest of the raw 64-byte key:
\[
    a_{\text{eth}} = \mathrm{Keccak\text{-}256}\bigl(Q_u[1{:}65]\bigr)[12{:}32]
\]

\subsubsection{Circuit Specification}

The Ethereum circuit mirrors the Bitcoin circuit structurally, with two substitutions in the cryptographic primitives:

\begin{itemize}
    \item \textbf{Public inputs:} The Ethereum address $a_{\text{eth}} \in \{0,1\}^{160}$ and the post-quantum public key $pk_{pq}$.
    \item \textbf{Private inputs:} The uncompressed public key $Q_u \in \{0,1\}^{520}$ and the ECDSA signature $\sigma$.
\end{itemize}

\begin{enumerate}[label=\textbf{C\arabic*.}]
    \item \textbf{Address binding.} $\mathrm{Keccak\text{-}256}(Q_u[1{:}65])[12{:}32] \stackrel{!}{=} a_{\text{eth}}$.
    \item \textbf{Ownership proof.} $\mathrm{ECDSA.Verify}\bigl(Q_u,\; \mathrm{Keccak\text{-}256}(a_{\text{eth}}),\; \sigma\bigr) \stackrel{!}{=} 1$.
\end{enumerate}

The use of Keccak-256 (rather than SHA-256) for both address derivation and message hashing aligns with Ethereum's native conventions. The PQ key format validation (\textbf{C3} in the implementation) additionally asserts $|pk_{pq}| \in \{1312, 1952, 2592\}$ bytes.

\subsection{Proof Generation and On-Chain Verification}
\label{subsec:proof-flow}

Users generate quantum-resistant key pairs offline and produce STARK proofs via the zkVM circuit, binding their classical addresses to the new post-quantum public keys. Crucially, the classical elliptic-curve public key is supplied to the circuit as a \emph{private input} and is never revealed on-chain---it is consumed only within the zero-knowledge execution trace. The resulting proof $\pi$, together with the public values $(a, pk_{pq})$ and the verification key $vk$, suffices for any verifier to confirm the binding without learning $Q$ or $sk$.

This design preserves the hash-based protection of unexposed addresses: even if an adversary observes $\pi$ and $pk_{pq}$ on the blockchain, they gain no information about the original public key beyond what is already implied by the address $a$ (which is itself a hash image).

\subsection{Migration Strategies}
\label{subsec:migration-strategies}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.65\textwidth]{imgs/Securing-Coinbase-Txs.jpg}
    \caption{Overview of the proposed framework for securing coinbase transactions using post-quantum signatures and zkSTARKs. Green elements denote public values; red elements denote private (witness) values.}
    \label{fig:securing-coinbase}
\end{figure}

We distinguish two scenarios based on the exposure status of the classical public key, as each entails a different threat model and accordingly requires a different migration protocol.

\subsubsection{Scenario~A: Exposed Public Keys --- Hybrid Dual-Signature Migration}
\label{subsubsec:exposed}

In both Bitcoin and Ethereum, a user's elliptic-curve public key is revealed the first time they sign a transaction. Once $Q$ appears on-chain, an adversary equipped with a cryptographically relevant quantum computer (CRQC) can apply Shor's algorithm~\cite{shor1994} to recover $sk$ in time polynomial in $\log |\mathbb{G}|$, rendering all funds controlled by $Q$ vulnerable. We therefore propose a \emph{hybrid dual-signature} migration for exposed addresses:

\begin{enumerate}[label=\textbf{Step~\arabic*.}]
    \item \textbf{Post-quantum key generation.} The user generates an ML-DSA key pair $(sk_{pq}, pk_{pq})$ under FIPS-204 at the desired security level (ML-DSA-44/65/87).

    \item \textbf{Classical attestation.} The user signs the post-quantum public key $pk_{pq}$ with their ECDSA private key $sk$, producing $\sigma_{\text{ecdsa}} = \mathrm{ECDSA.Sign}(sk, pk_{pq})$. This binds $pk_{pq}$ to the classical identity under the still-secure pre-quantum assumption.

    \item \textbf{Quantum-resistant attestation.} The user signs the migration message (containing $a$ and $pk_{pq}$) with the ML-DSA private key $sk_{pq}$, producing $\sigma_{pq} = \mathrm{ML\text{-}DSA.Sign}(sk_{pq}, a \| pk_{pq})$. This proves liveness of the post-quantum key.

    \item \textbf{On-chain registration.} Both signatures (or their hashes, for gas efficiency) are submitted to the migration contract or embedded in a Bitcoin transaction. Validators check:
    \begin{enumerate}[label=(\alph*)]
        \item the ECDSA signature $\sigma_{\text{ecdsa}}$ under $Q$ (verifying classical ownership),
        \item the ML-DSA signature hash $h_\sigma = \mathrm{keccak256}(\sigma_{pq})$ (enabling off-chain quantum-resistant verification), and
        \item the format validity of $pk_{pq}$ ($|pk_{pq}| \in \{1312, 1952, 2592\}$).
    \end{enumerate}

    \item \textbf{Post-quantum continuation.} Future transactions from $a$ are authorized under $pk_{pq}$ using ML-DSA signatures, eliminating dependence on the classical key pair entirely.
\end{enumerate}

This hybrid approach ensures backward compatibility with existing validation infrastructure while layering quantum-resistant guarantees. The dual-signature requirement during the transition window provides defense in depth: an adversary must compromise \emph{both} the classical and post-quantum keys to forge a migration.

For Bitcoin specifically, we propose the introduction of a dedicated opcode \texttt{OP\_CHECKQUANTUMSIG} (\texttt{0xbb}) that:

\begin{enumerate}[label=(\roman*)]
    \item verifies a zkSTARK proof demonstrating knowledge of the original ECDSA private key,
    \item validates the ML-DSA signature against the declared post-quantum public key, and
    \item authorizes spending of the UTXO upon successful verification of both conditions.
\end{enumerate}

Once quantum-resistant schemes achieve broad community acceptance and rigorous standardization review, the network can transition to \emph{exclusively} post-quantum signatures, completing the migration. This graduated approach protects assets against emerging quantum threats while minimizing disruption to network stability and operational continuity.

\subsubsection{Scenario~B: Unexposed Public Keys --- Zero-Knowledge Migration via zkSTARKs}
\label{subsubsec:unexposed}

When the classical public key has never been revealed---as is the case for unspent P2PKH UTXOs in Bitcoin and EOAs that have never initiated a transaction in Ethereum---the address $a$ is protected by the SHA-256/RIPEMD-160 (Bitcoin) or Keccak-256 (Ethereum) hash barrier. This pre-image resistance provides an additional layer of quantum resistance, since Grover's algorithm offers only a quadratic speedup against hash functions, insufficient to break 256-bit hashes in practice.

However, this protection is \emph{ephemeral}: the classical public key $Q$ is necessarily revealed the moment the user constructs a spending transaction. At that instant, $Q$ becomes vulnerable to Shor's algorithm. We therefore propose using the zkSTARK circuits described in Sections~\ref{subsec:btc-circuit} and~\ref{subsec:eth-circuit} to prove knowledge of $sk$ and bind $pk_{pq}$ \emph{without ever revealing $Q$~on-chain}.

Concretely, consider a user (e.g., Satoshi) controlling a coinbase UTXO associated with a key pair $(sk, Q)$ in a world where a CRQC exists:

\begin{enumerate}[label=\textbf{Step~\arabic*.}]
    \item \textbf{Post-quantum key generation.} Generate $(sk_{pq}, pk_{pq})$ under ML-DSA at the desired security level.

    \item \textbf{Proof generation.} Execute the Bitcoin STARK circuit (Section~\ref{subsec:btc-circuit}) with private inputs $(Q, \sigma)$ and public inputs $(a, pk_{pq})$. The resulting proof $\pi$ attests that:
    \begin{itemize}
        \item the prover knows a pre-image $Q$ such that $f_{\text{P2PKH}}(Q) = a$, and
        \item the prover can produce a valid ECDSA signature under $Q$.
    \end{itemize}
    At no point is $Q$ transmitted off-device or committed to any public channel.

    \item \textbf{Transaction construction.} Construct a spending transaction that includes the STARK proof $\pi$, the post-quantum public key $pk_{pq}$, and (optionally) an ML-DSA signature. The conceptual script takes the form:
    \begin{verbatim}
    OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY
    <zkSTARKProof> <pk_q> OP_CHECKSTARKPROOF
    OP_CHECKQUANTUMSIG
    \end{verbatim}

    Here, \texttt{OP\_CHECKSTARKPROOF} (\texttt{0xbc}) verifies that the STARK proof is valid with respect to the verification key and the declared public inputs, while \texttt{OP\_CHECKQUANTUMSIG} (\texttt{0xbb}) validates the post-quantum signature for future spending authorization.

    \item \textbf{Miner validation.} Miners (or full nodes) verify $\pi$ against the circuit's verification key, confirm the consistency of $(a, pk_{pq})$, and---upon acceptance---include the transaction in the blockchain, marking the original UTXO as spent.

    \item \textbf{Post-quantum continuation.} A new UTXO is created, locked to $pk_{pq}$. The user employs $(sk_{pq}, pk_{pq})$ for all subsequent transactions, achieving full quantum resistance. The original key pair $(sk, Q)$ is effectively retired without having been exposed.
\end{enumerate}

\begin{remark}
This zero-knowledge migration protocol requires that the Bitcoin protocol be upgraded to support STARK proof verification and the proposed custom opcodes on-chain. While such capabilities are not present in Bitcoin today, the framework is immediately deployable on EVM-compatible chains (via the \texttt{PQBitcoin.sol} smart contract) and on Bitcoin Layer~2 networks, providing practical migration pathways in advance of any consensus-layer changes. The BIP draft accompanying this work (Appendix) specifies the opcode semantics, resource limits, and activation mechanism in full detail.
\end{remark}
