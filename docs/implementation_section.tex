
\section{Implementation and Benchmarking}
\label{sec:implementation}

\subsection{System Architecture}

We realize the post-quantum migration framework as a modular, open-source toolchain comprising four principal components: (i)~a shared cryptographic library implementing address derivation and key validation primitives, (ii)~two SP1 zkVM guest programs encoding the migration constraints as verifiable circuits, (iii)~a Solidity smart contract providing on-chain proof verification with an incremental Merkle registry, and (iv)~a suite of host-side orchestration scripts and a Bitcoin OP\_RETURN indexer. The complete implementation totals approximately 4,200 lines of Rust and 400 lines of Solidity, verified by 178 automated tests.

\subsection{Zero-Knowledge Circuit Design}
\label{subsec:circuits}

SP1~\cite{sp1} is a general-purpose zero-knowledge virtual machine that compiles Rust programs to the RISC-V instruction set and generates STARK proofs of correct execution via the FRI (Fast Reed-Solomon Interactive Oracle Proof) protocol. We exploit this capability to construct two \emph{guest programs}---one for Bitcoin and one for Ethereum---each encoding the cryptographic constraints that bind a classical address to a post-quantum public key.

\subsubsection{Bitcoin Migration Circuit}

Let $Q \in \mathbb{G}$ denote a compressed secp256k1 public key (33 bytes), $\sigma \in \{0,1\}^{512}$ a compact ECDSA signature, $a$ the corresponding P2PKH address (25 bytes), and $pk_{pq}$ an ML-DSA public key. The Bitcoin circuit enforces the following three constraints within the zkVM:

\begin{enumerate}[label=\textbf{C\arabic*.}, leftmargin=2em]
    \item \textbf{Ownership proof.} Verify that $\sigma$ is a valid ECDSA signature under $Q$ over the message $m = \mathrm{SHA\text{-}256}(a)$:
    \[
        \mathrm{ECDSA.Verify}\!\left(Q,\; \mathrm{SHA\text{-}256}(a),\; \sigma\right) \stackrel{!}{=} 1
    \]
    This establishes that the prover possesses the private key $d$ satisfying $Q = d \cdot G$ on the curve secp256k1.

    \item \textbf{Address binding.} Independently derive the P2PKH address from $Q$ and assert consistency:
    \[
        a' = \texttt{0x00} \;\big\|\; \mathrm{RIPEMD\text{-}160}\!\left(\mathrm{SHA\text{-}256}(Q)\right) \;\big\|\; c_4, \qquad a' \stackrel{!}{=} a
    \]
    where $c_4$ denotes the first four bytes of $\mathrm{SHA\text{-}256}^2\!\left(\texttt{0x00} \| \mathrm{RIPEMD\text{-}160}(\mathrm{SHA\text{-}256}(Q))\right)$. This prevents a malicious prover from claiming ownership of an address derived from a different key.

    \item \textbf{Key format validation.} Assert that the post-quantum public key has a valid ML-DSA size:
    \[
        |pk_{pq}| \in \{1312,\; 1952,\; 2592\} \;\text{bytes}
    \]
    corresponding to ML-DSA-44 (NIST Level~2), ML-DSA-65 (Level~3), and ML-DSA-87 (Level~5), respectively, as specified in FIPS-204~\cite{fips204}.
\end{enumerate}

Upon successful constraint satisfaction, the circuit commits the tuple $(a, pk_{pq})$ as ABI-encoded public values via the SP1 I/O channel. These values constitute the \emph{statement} of the resulting proof and are later decoded on-chain by the verification contract.

\subsubsection{Ethereum Migration Circuit}

The Ethereum circuit is structurally analogous but substitutes the relevant cryptographic primitives: ECDSA verification operates on a 65-byte uncompressed public key with Keccak-256 message hashing, and the address is derived as the trailing 20 bytes of the Keccak-256 digest of the raw (prefix-stripped) public key:
\[
    a_{\text{eth}} = \mathrm{Keccak\text{-}256}(Q_{\text{raw}})[12{:}32]
\]

The PQ key validation constraint (\textbf{C3}) remains identical across both circuits.

\subsection{Proof Generation Pipeline}
\label{subsec:pipeline}

The end-to-end proof generation pipeline proceeds through five stages, transforming private cryptographic inputs into a succinct, EVM-verifiable proof:

\begin{enumerate}[label=\textbf{Stage~\arabic*.}]
    \item \textbf{Key generation and signing.} The host script generates a secp256k1 keypair $(d, Q)$ via \texttt{OsRng} and an ML-DSA-65 keypair $(sk_{pq}, pk_{pq})$ via FIPS-204 deterministic key generation from a 32-byte seed. The private key $d$ signs the derived address to produce $\sigma$.

    \item \textbf{zkVM execution.} The inputs $(Q, a, \sigma, pk_{pq})$ are serialized into the SP1 standard input channel and executed inside the RISC-V environment. In execute-only mode (no proof), this incurs approximately $5.41 \times 10^5$ cycles and completes in ${\sim}90$\,ms on contemporary hardware (Apple M-series).

    \item \textbf{STARK proof generation.} The SP1 prover records the full execution trace, encodes it as polynomials over a prime field $\mathbb{F}_p$, checks AIR (Algebraic Intermediate Representation) constraints, and applies the FRI folding protocol to produce a STARK proof $\pi_{\text{STARK}}$.

    \item \textbf{SNARK wrapping.} For on-chain verification, $\pi_{\text{STARK}}$ is recursively composed and wrapped into either a Groth16 or PLONK proof via SP1's built-in recursion pipeline. The resulting proof $\pi_{\text{EVM}}$ has constant size (${\sim}260$ bytes for Groth16, ${\sim}800$ bytes for PLONK) and constant verification cost.

    \item \textbf{Fixture serialization.} The wrapped proof, public values, and verification key are serialized into a JSON fixture consumed by the Solidity test suite for end-to-end on-chain verification.
\end{enumerate}

\subsection{On-Chain Verification Contract}
\label{subsec:contract}

The \texttt{PQBitcoin.sol} smart contract (304 lines, Solidity $\geq 0.8.20$) serves as the on-chain verification endpoint. It delegates proof verification to the \texttt{SP1VerifierGateway} and implements four security and functionality layers:

\subsubsection{Access Control}

Administrative state variables---the verifier gateway address and the SP1 program verification key---are protected by a manually implemented Ownable2Step pattern. Ownership transfer requires two transactions: the current owner initiates via \texttt{transferOwnership($\cdot$)}, setting a \texttt{pendingOwner}; the designated successor completes via \texttt{acceptOwnership()}. This two-phase commit eliminates the risk of irrevocable transfers to erroneous addresses. All access violations revert with gas-efficient custom Solidity errors (\texttt{Unauthorized}, \texttt{NotPendingOwner}).

\subsubsection{Post-Quantum Key Validation}

An internal pure function \texttt{\_validatePQKeySize} enforces that decoded public keys match one of the three standardized ML-DSA sizes ($|pk_{pq}| \in \{1312, 1952, 2592\}$). This check is applied in both state-modifying and view-only verification paths, rejecting malformed inputs with a typed error \texttt{InvalidPQKeySize(uint256)} before any state mutation.

\subsubsection{Hybrid Dual-Signature Migration}

Beyond the standard STARK-based migration, the contract supports a \emph{hybrid dual-signature} mode via \texttt{verifyDualSigMigration}. In addition to verifying the SP1 proof (which attests to ECDSA ownership), the caller submits an ML-DSA signature $\sigma_{pq}$ over the migration message. The contract computes and stores its Keccak-256 hash:
\[
    h_\sigma = \mathrm{keccak256}(\sigma_{pq})
\]
in the \texttt{pqSignatures} mapping. This on-chain commitment enables any third party to independently verify that the holder of $pk_{pq}$ explicitly authorized the migration by checking $\mathrm{keccak256}(\sigma'_{pq}) \stackrel{?}{=} h_\sigma$ against a claimed signature $\sigma'_{pq}$. Full on-chain ML-DSA verification is deliberately deferred: at approximately $5 \times 10^6$ gas for a single ML-DSA-65 verification in Solidity, the hash commitment provides equivalent assurance at ${\sim}25$K gas---a $200\times$ reduction.

\subsubsection{Incremental Merkle Migration Registry}

Every successful migration (standard or dual-signature) is recorded in an append-only incremental Merkle tree of depth $d = 20$, supporting up to $2^{20} = 1{,}048{,}576$ distinct migrations. Each leaf is computed as:
\[
    \ell_i = \mathrm{keccak256}\!\left(a_i \;\big\|\; \mathrm{keccak256}(pk_{pq,i})\right)
\]

The tree uses pre-computed zero hashes for empty subtrees and achieves $O(d)$ insert complexity at approximately $6 \times 10^4$ gas per operation (20 Keccak-256 invocations). The contract exposes \texttt{getMerkleRoot()} and \texttt{getMigrationCount()} as view functions, enabling light clients to verify migration inclusion via standard Merkle proofs without transacting with or downloading the full contract state. The emitted events (\texttt{AddressMigrated}, \texttt{DualSigMigrated}) include the leaf index and updated root, permitting off-chain proof reconstruction from event logs alone.

\subsection{Bitcoin On-Chain Registry}
\label{subsec:bitcoin-integration}

Bitcoin's lack of Turing-complete scripting necessitates a multi-path strategy. We implement four complementary approaches with increasing levels of consensus enforcement:

\subsubsection{OP\_RETURN Hash Commitments}

The SDK generates a compact 71-byte payload embedding SHA-256 hashes of both the PQ public key and the STARK proof, structured as:

\smallskip
\noindent
\begin{tabular}{|c|c|c|c|c|c|}
\hline
\textbf{Magic (4B)} & \textbf{Ver (1B)} & \textbf{PQ Key Hash (32B)} & \textbf{Proof Hash (32B)} & \textbf{Flags (1B)} & \textbf{Level (1B)} \\
\hline
\texttt{PQMG} & \texttt{0x01} & $\mathrm{SHA\text{-}256}(pk_{pq})$ & $\mathrm{SHA\text{-}256}(\pi)$ & & \\
\hline
\end{tabular}
\smallskip

This payload fits within Bitcoin's 80-byte OP\_RETURN limit. The flags byte encodes proof type (Groth16 \texttt{0x01}, PLONK \texttt{0x02}) and migration mode (dual-sig \texttt{0x04}). A companion indexer service (808 lines, Axum/Tokio) scans the blockchain for \texttt{PQMG}-prefixed outputs and maintains a queryable REST API.

Verification is straightforward: given a claimed public key $pk'_{pq}$, any party can check $\mathrm{SHA\text{-}256}(pk'_{pq}) \stackrel{?}{=} H_{\text{committed}}$ against the on-chain hash.

\subsubsection{Taproot Script Path (BIP-341)}

The SDK constructs Taproot (BIP-341) outputs with a two-leaf script tree:

\begin{itemize}
    \item \textbf{Leaf~0 (PQ Commitment):} \texttt{OP\_SHA256 \textlangle pk\_hash\textrangle{} OP\_EQUALVERIFY OP\_TRUE} --- spending requires revealing the PQ key pre-image.
    \item \textbf{Leaf~1 (Timelock Fallback):} \texttt{\textlangle N\textrangle{} OP\_CSV OP\_DROP OP\_TRUE} --- allows recovery after $N$ relative blocks.
\end{itemize}

The Merkle root of this script tree is combined with the internal key $P$ via the BIP-341 tweaking procedure:
\[
    Q = P + \mathrm{TaggedHash}(\texttt{"TapTweak"},\; P \| r_{\text{merkle}}) \cdot G
\]

The implementation includes full Bech32m (BIP-350) encoding, tagged hash computation (BIP-340), and control block generation for both spending paths.

\subsubsection{Bitcoin L2 Deployment}

EVM-compatible Bitcoin sidechains and rollups (BOB, Citrea, Botanix) permit deploying \texttt{PQBitcoin.sol} without modification, providing a complete smart contract registry while inheriting Bitcoin's security guarantees through each L2's respective settlement mechanism.

\subsubsection{Proposed Soft Fork: \texttt{OP\_CHECKQUANTUMSIG}}

As a long-term proposal, we specify two new opcodes in a BIP draft included with the implementation:

\begin{itemize}
    \item \textbf{\texttt{OP\_CHECKQUANTUMSIG} (\texttt{0xbb}):} Natively verifies an ML-DSA digital signature in Bitcoin Script. The opcode auto-detects the security level from $|pk_{pq}|$ and applies FIPS-204 verification semantics.
    \item \textbf{\texttt{OP\_CHECKSTARKPROOF} (\texttt{0xbc}):} Verifies a STARK proof binding a Bitcoin address to a post-quantum public key, consuming $(vkey, a, pk_{pq}, \pi)$ from the stack.
\end{itemize}

These opcodes are defined as Tapscript extensions under leaf version \texttt{0xc2}, preserving backward compatibility with existing \texttt{0xc0} Tapscript. Activation follows the BIP-9 version bits mechanism. Resource limits bound computational cost: at most 100 PQ operations per block, with ML-DSA verification weighted at 50,000 sigops-equivalent.

\textbf{Migration script example:}
\begin{verbatim}
    scriptPubKey:   <btc_address> <pq_pubkey> <vkey>
                    OP_CHECKSTARKPROOF OP_VERIFY
    witness:        <stark_proof>
\end{verbatim}

\subsection{Performance Evaluation}
\label{subsec:benchmarks}

\subsubsection{Proof Generation}

Table~\ref{tab:zkvm-bench} summarizes the computational cost of the proof pipeline for the Bitcoin circuit with ML-DSA-65 (1,952-byte) keys.

\begin{table}[ht]
\centering
\caption{SP1 proof generation benchmarks (Bitcoin circuit, ML-DSA-65).}
\label{tab:zkvm-bench}
\begin{tabular}{l r l}
\toprule
\textbf{Metric} & \textbf{Value} & \textbf{Environment} \\
\midrule
RISC-V instruction count       & $5.41 \times 10^5$   & --- \\
Execute-only latency            & ${\sim}90$\,ms        & Apple M-series \\
STARK proof (FRI)               & ${\sim}$minutes       & SP1 prover network \\
Groth16 wrapping                & ${\sim}5$\,min        & Includes recursion \\
PLONK wrapping                  & ${\sim}5$\,min        & Includes recursion \\
Groth16 proof size              & 260\,B               & Constant \\
PLONK proof size                & 800\,B               & Constant \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{On-Chain Verification Cost}

Table~\ref{tab:gas-costs} reports the Ethereum gas consumption for the principal contract operations, measured via the Foundry test framework with mocked SP1 verification.

\begin{table}[ht]
\centering
\caption{Gas costs for \texttt{PQBitcoin.sol} operations (Foundry, EVM Shanghai).}
\label{tab:gas-costs}
\begin{tabular}{l r}
\toprule
\textbf{Operation} & \textbf{Gas} \\
\midrule
\texttt{verifyMigrationProof} (standard)      & ${\sim}390{,}000$ \\
\texttt{verifyDualSigMigration} (hybrid)       & ${\sim}670{,}000$ \\
Incremental Merkle insert (per leaf)            & ${\sim}60{,}000$ \\
\texttt{updateVerifier} (admin)                 & ${\sim}21{,}000$ \\
\texttt{transferOwnership} (initiate)           & ${\sim}41{,}000$ \\
\texttt{acceptOwnership} (complete)             & ${\sim}37{,}000$ \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Test Coverage}
\label{subsec:tests}

The implementation is verified by 178 automated tests spanning four domains (Table~\ref{tab:tests}).

\begin{table}[ht]
\centering
\caption{Automated test coverage by component.}
\label{tab:tests}
\begin{tabular}{l r p{7.2cm}}
\toprule
\textbf{Suite} & \textbf{Tests} & \textbf{Coverage} \\
\midrule
Rust unit tests        & 99  & BTC/ETH address derivation, ML-DSA validation (boundary sizes $\pm 1$B), ABI encoding, OP\_RETURN codec, Taproot tagged hashes, script construction \\
Rust integration       & 12  & End-to-end migration lifecycle for all three ML-DSA levels, hash verification, flag permutations \\
Rust doctests          & 2   & Crate-level API usage examples \\
Indexer tests          & 23  & Payload decoder, in-memory store (insert, dedup, lookup), REST endpoints (8 API tests) \\
Solidity tests         & 42  & Groth16/PLONK verification (12), Ownable2Step access control (11), PQ key validation (8), dual-signature commitment (6), Merkle tree transitions (5) \\
\midrule
\textbf{Total}         & \textbf{178} & \\
\bottomrule
\end{tabular}
\end{table}

The source code is publicly available at \url{https://github.com/skardas/pq_bitcoin}.
